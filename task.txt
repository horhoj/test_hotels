1 задание

Есть 90 человек.
Каждый из этих 90 человек относится к одной из двух категорий.
Одни на все вопросы говорят правду, другие — всегда врут.
У каждого ровно 1 любимое блюдо из списка (макароны/пельмени/вареники).
Каждому задают три вопроса:
Ваше любимое блюдо — макароны?
Ваше любимое блюдо — пельмени?
Ваше любимое блюдо — вареники?
Результаты получились такие:
на первый вопрос утвердительно ответило 45 человек,
на второй — 35,
на третий — 30.
Сколько человек всегда говорят правду?

решение 1 задания: 

Так как лжецы всегда говорят ложь,
а любимое блюдо всегда только одно,
то лжецы генерируют в два раза больше ответов чем правдолюбы.

Если бы все были правдолюбы, то общее кол-во всех ответов было бы равно 90.

Так как общее кол-во любимых блюд 45+30+35 = 110.
То очевидно что все что превышает 90, это лишняя информация генерируемая лжецами.
А так как лжец всегда генерирует (в вопросе любимых блюд) ровно в два раза больше чем правдолюб,
то превышение кол-ва любимых блюд над кол-вом людей и есть кол-во лжецов.

Следовательно лжецов 110 - 90 = 20 человек.

следовательно всегда говорят правду 90 - 20 = 70 человек.

******************************

2 задание

Есть числа от трех до одиннадцати.
Есть квадрат — 3 на 3 клетки:
а б в
г д е
ё ж з
(Буквы ничего не значат, кроме того, что числа не повторяются)
Можно ли расставить числа в клетки квадрата таким образом,
что перемножения чисел в строках дает тот же результат,
что и произведение чисел в столбцах с теми же номерами?
Если можно — расставьте, если нельзя — объясните почему.

решение 2 задания:

Согласно правилам математики,
произведение чисел можно заменить сложением их логарифмов по какому-нибудь основанию.
Таким образом решение задачи можно свести к получению соответствующих логарифмов
(например по основанию 2) данного набора чисел и проверке сумм для соответствующих столбцов и строк.
Для поиска готового набора чисел можно взять готовый набор логарифмов
и произвести возведение в степень по нужному основанию.

например это магический квадрат (сумма любого ряда, столбца или диагонали равна 15)
|8, 1, 6|
|3, 5, 7|
|4, 9, 2|

таким образом возведя 2 в степень равную каждому элементу
этого квадрата мы получим (произведение каждого ряда,
столбца и диагонали, будет составлять 2 в 15 степени === 32768)

| 256, 2, 64 |
| 8, 32, 128 | 
| 16, 512, 4 |

В целом общее правило:
Логарифмируем набор чисел по любому основанию.
Если соответствующий набор логарифмов расставляется с
одинаковыми суммами по соответствующим рядам и столбцам,
то набор чисел можно расставить таким образом, чтобы произведение
соответсвующих строк было равно произведению соотвествующих столбцов.


******************************
3 задание
Ученые разработали новый материал неизвестной прочности.
Они знают, что материал разбивается при падении с высоты от 1 метра до 5 000 метров.
Но не знают, с какой именно высоты. Чтобы определить прочность,
ученые поднимают предмет на некоторую высоту и сбрасывают его оттуда.
Их задача — определить, начиная с какой именно высоты предмет начнет разбиваться.
Специальная платформа, с помощью которой они осуществляют эксперимент,
скидывает предмет только с дискретных высот (1, 2, 3 ... 4999, 5000 метров — платформа
не может скинуть предмет, например, с 2,5 метров. Точности в 1 метр ученым вполне достаточно).
При падении с высоты "n" метров предмет уничтожается. Если же его сбрасывали с высоты ниже "n",
то его можно использовать в повторных экспериментах.
Нужно АБСОЛЮТНО ТОЧНО найти ту высоту, начиная с которой предметы разрушаются.
Сделать это нужно за МИНИМАЛЬНО возможное число экспериментов.
У ученых при этом всего 2 предмета, но они абсолютно одинаковые.
Каким образом этого можно достигнуть?
Сколько экспериментов при этом максимально потребуется?

решение 3 задачи:

Это задание на бинарный поиск:
мы просто сначала берем половину высоты (что от 5000 составляет 2500 метров) и
смотрим разбивается ли материал выше или ниже данной точки
(ну те. если разбился то берем значение ниже, если нет, то выше).
Далее берем все значения соответствующие новому промежутку
(например от 2500 до 5000 если материал разбился на высоте выше 2500 тысяч)
опять находим их середину (это в моем примере (5000+2500) / 2 = 3750)
и повторяем данный цикл до установления точного значения.
В целом максимальное число попыток будет равно логарифму
по основанию 2 от n (где n это кол-во элементов, т.е. в данном случае 5000)


******************************
4 задание 
В университетскую столовую пришли
трое студентов купить пирожки.
Один хочет купить треть всех имеющихся
в столовой пирожков и еще 2 пирожка.
Другой хочет купить четверть от всех имеющихся пирожков и ещё 3 пирожка.
А третий хочет купить пятую часть всех пирожков и ещё 8 пирожков.
Если все трое купят столько пирожков, сколько планируют,
то в столовой как раз закончатся все пирожки. Сколько пирожков есть в столовой?

решение 4 задачи:

пусть Х это число всех пирожков.
Тогда (1/3*x +2) это хочет купить первый студент,
тогда (1/4*x +3) это хочет купить второй студент,
а (1/5*x+8) это третий.

тогда если в общем они хотят купить все пирожки, то получим уравнение:
(1/3*x +2) + (1/4*x +3) + (1/5*x+8) = x;
или
(1/3 + 1/4 + 1/5)*x - x = -13
откуда x = 60

Ответ: в столовой было 60 пирожков.




******************************
Задачи на программирование. Я использовал JavaScript. 

******************************
1.Написать метод/функцию, который/которая на вход принимает массив городов.
В качестве результата возвращает строку, где города разделены запятыми,
а в конце стоит точка.

Пример: «Москва, Санкт-Петербург, Воронеж.» 

решение 1 задачи:
!!При решении задачи я не использовал стандартные методы
например для массивов, типа join, так как я понял суть задачи,
в том чтобы использовать их аналоги, разработанные самостоятельно.

//------
const cityList = ['Москва', 'Санкт-Петербург', 'Воронеж'];

const fn = (cityList) => {
  let str = '';
  for (let i = 0; i < cityList.length; i++) {
    if (i > 0) {
      str = str + ', ';
    }
    str = `${str + cityList[i]}`;
  }

  return str + '.';
};

console.log(fn(cityList));
//------

******************************

Написать метод/функцию, который/которая на вход принимает число (float),
а на выходе получает число, округленное до пятерок.

Пример:
27 => 25, 27.8 => 30, 41.7 => 40.

решение 2 задачи:
//------

const fn = (floatNumber) => {
  const border = 5;

  const oct = floatNumber % border;

  const value = floatNumber - oct;

  const offset = border / 2 > oct ? 0 : border;

  return value + offset;
};

console.log(fn(27));
console.log(fn(27.8));
console.log(fn(41.7));
//------

******************************
Задача 3
Написать метод/функцию,
который/которая на вход принимает число (int),
а на выходе выдает слово “компьютер” в падеже,
соответствующем указанному количеству.
Например, «25 компьютеров», «41 компьютер», «1048 компьютеров».

решение 3 задачи:
//------
const fn = (count) => {
  const SUFFIX_LIST = {
    1: '',
    2: 'а',
    3: 'а',
    4: 'а',
    5: 'ов',
    6: 'ов',
    7: 'ов',
    8: 'ов',
    9: 'ов',
    0: 'ов',
  };

  const STR = 'компьютер';

  return count + ' ' + STR + SUFFIX_LIST[count % 10];
};

console.log(fn(100));
console.log(fn(1022));
console.log(fn(27));
console.log(fn(41));
console.log(fn(1048));
//------

******************************
Задача 4

Написать метод/функцию,
который/которая на вход принимает целое число,
а на выходе возвращает то, является ли число простым (не имеет делителей кроме 1 и самого себя).

решение 4 задачи:
//------
const isPrimeNumber = (value) => {
  //так как простыми могут быть только натуральные числа большие 1
  if (value < 2) {
    return false;
  }

  for (let i = 2; i < value - 1; i++) {
    if (value % i === 0) {
      return false;
    }
  }

  return true;
};

Array(10)
  .fill(null)
  .forEach((_, index) => {
    console.log(index + 1, isPrimeNumber(index + 1));
  });
//------

******************************
Задача 5
Написать метод, который определяет,
какие элементы присутствуют в двух экземплярах
в каждом из массивов (= в двух и более, причем в каждом).
На вход подаются два массива. На выходе массив с необходимыми совпадениями.

Пример:
[7, 17, 1, 9, 1, 17, 56, 56, 23], [56, 17, 17, 1, 23, 34, 23, 1, 8, 1]
На выходе [1, 17]

решение 5 задачи:
//------
const arr1 = [7, 17, 1, 9, 1, 17, 56, 56, 23];
const arr2 = [56, 17, 17, 1, 23, 34, 23, 1, 8, 1];

const fn = (arr1, arr2) => {
  const result = [];

  const count = (arr) => {
    const result = {};
    arr.forEach((item) => {
      if (result[item]) {
        result[item] = result[item] + 1;
        return;
      }

      result[item] = 1;
    });
    return result;
  };

  const countListFiltered = (countList) =>
    Object.keys(countList).filter((key) => countList[key] >= 2);

  const countList1 = countListFiltered(count(arr1));
  const countList2 = countListFiltered(count(arr2));

  countList1.forEach((item) => {
    if (countList2.includes(item)) {
      result.push(item);
    }
  });

  return result;
};

console.log(fn(arr1, arr2));
//------

******************************
задача 6 
Написать метод, который в консоль выводит таблицу умножения.
На вход метод получает число, до которого выводит таблицу умножения.
В консоли должна появиться таблица.
Важно: 
В последней строке между числами ровно по одному пробелу должно выводиться. 
В каждом столбце числа должны быть выровнены по правому краю.


решение 6 задачи:
//------
const getMultiplicationTable = (limit) => {
  const result = [
    [
      ' ',
      ...Array(limit)
        .fill(null)
        .map((_, i) => i + 1),
    ],
  ];
  for (let i = 0; i < limit; i++) {
    const row = [i + 1];
    for (let j = 0; j < limit; j++) {
      row.push((i + 1) * (j + 1));
    }
    result.push(row);
  }

  const maxLength = (limit * limit).toString().length;

  result.forEach((row) => {
    const rowView = row
      .map((item) => {
        const offset = maxLength - item.toString().length;
        const offsetStr = Array(offset).fill(' ').join('');
        return `${offsetStr}${item}`;
      })
      .join(' ');
    console.log(rowView);
  });
};

getMultiplicationTable(20);

//------



